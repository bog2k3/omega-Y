[ConnectionWrapper class]
	* higher level wrapper over net::connection
	* holds metadata about the connection such as
		- isAlive or enum state.
		- ping time
		- peerInfo: { userName, reputation, avatar, UUID} (UUID is randomly generated by the server for each connection;
														   if the same peer reconnects after a disconnect, it will use the UUID
														   to tell the server it's the same dude)
	* provides methods for reading/writing asynchronously from/to the net::connection via a shared worker thread
	* implements negociation protocol and sets a flag upon completion of negociation - this means the connection is ready to be used by the game.

[NetHost class]
	* imlements NetAdapter interface
	* holds a list of ConnectionWrappers that represent connected clients.
	* broadcasts local game events to all clients
	* receives game events from each client and broadcasts them to all other clients

[NetClient class]
	* imlements NetAdapter interface
	* holds a single ConnectionWrapper for the connection with the host
	* sends local game events to the host
	* receives remote game events from the host

[NetAdapter]
	* both [NetHost] and [NetClient] objects are accessed via a [NetAdapter] interface, thus the rest of the code does not care about host/client identity.
	* this interface performs the relevant actions on network peers depending on wether it's a host or client type
	* The game code is isolated from network classes except for this interface.
	* implements the higher level communication protocol

[Host peer]
	* holds NetHost object
		+ NetHost holds a list of connected clients
	* responsible for flow control:
		+ create and end sessions
		+ create shared resources (terrain, sky, etc) -> synchs via seeds and they're recomputed on the clients
		+ starts and ends game
	* updates local player; receives updates from clients' player objects;
		+ broadcasts all player updates to all clients
	* receives and broadcasts game events to/from all clients (bullet creation, relevant collisions etc)
		+ bullets are created and simulated separately on each client

[Client peer]
	* holds NetClient object
	* receives flow commands from Host
		+ receives resource seeds (terrain, sky etc) and computes them locally
		+ receives start/end game commands
	* updates local player; notifies the host of the modifications
	* receives updates for other remote players from host - these are not simulated locally (except maybe some interpolation)
	* simulates bullets and other objects locally

[Arbitrage]
	* because most objects are simulated locally and independently on each peer, there are bound to arise desynchronizations.
	* we treat two categories of objects:
		1. projectiles (bullets, rockets etc)
		2. big and mostly stationary objects (boulders, crates etc)

	1. [projectiles]
		- creation event is synched across all peers
		- independent simulation on each peer
		- collision events *must* be synchronized such that all peers agree on them.
		- we use a majority vote to settle the arbitrage of events, or in case there is a draw,
			we randomly select one outcome (real quantum stuff, yeah) so that neither peer is consistently favoured over the other.
		- the host manages arbitrage (or in case we want to be really politically correct we can randomly choose one peer to do this).

		- we must design a deferred event strategy, where an event that occurred locally is recorded and held back until it is settled by
			arbitrage and only then the corresponding action is taken (or the event is dropped)
		- some events may not register at all on some peers (such as a bullet collision) so we need to send them some sort of "spurious" events
			as the arbitrage is done, and these events must be handled immediately.

	2. [big, mostly stationary objects]
		- these can exist from the begining (boulders, crates) or can be created dynamically (rubble when breaking a wall)
		- they can also be destroyed dynamically (breaking a crate)
		- these don't used deferred events, rather their attributes (position, velocity) are averaged out by the designated arbiter from the
			values collected from all peers and then an update is issued to all peers via the host

	* for other event types (such as damage taken by a player) a similar approach to #2 is taken - average out from all peers.
